#!/usr/bin/env python3

import sys
import argparse
import re
import sqlite3
import numpy as np
import matplotlib
import matplotlib.pyplot as plt

# TODO This was supposed to produce some interesting information using the 
# results from the SQLite database and the YAML configuration file.
# It was never finished.

argparser = argparse.ArgumentParser()
argparser.add_argument('-d', '--database', required=True, dest='db',
        help="SQLite3 database file generated by OptSearch")

def main(args):
    column_count = 0
    pattern = 'optsearch\.sqlite$'
    pat = re.compile(pattern)
    s = re.search(pat, args.db)
    # TODO A more intelligent check would be good
    if not s:
        print("This does not look like a SQLite database file generated by OptSearch.")
        exit(1)
    try:
        conn = sqlite3.connect(args.db)
        cur = conn.cursor()
        # Get column list via "pragma table_info(position);"
        # Now we know how many columns, and their names.
        # Returned results about each column are in this order:
        # cid|name|type|notnull|dflt_value|pk
        stmt = "SELECT "
        columns = "id"
        pos_id = 0
        for row in cur.execute("PRAGMA table_info(position);"):
            columns = "%s,%s" % (columns, row[1])
            column_count = column_count + 1
        print("there are {0} columns".format(column_count))

        stmt = "%s %s FROM position WHERE (id=%d);" % (stmt,
                columns, column_count - 1)

        print("Stmt is ",stmt)

        # TODO Things we want to know:
        # - Look at the distance (from the 'best' answer) of each of the global
        #   best positions over time.
        # - Look at the distance of each position chosen by a randomly selected
        #   particle over time.
        # - Analyse the distribution of fitness results across the positions
        #   tested.  Perhaps produce a histogram?
        # - Plot fitness of positions tested, as each one is analysed, with
        #   OptSearch's current_global_best at that time also noted.

        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()

#def plotsomething():
    # Fixing random state for reproducibility
    #np.random.seed(19680801)
    #matplotlib.rcParams['axes.unicode_minus'] = False
    #fig, ax = plt.subplots()
    #ax.plot(10*np.random.randn(100), 10*np.random.randn(100), 'o')
    #ax.set_title('Using hyphen instead of Unicode minus')
    #plt.show()

if __name__ == '__main__':
    args = argparser.parse_args()
    main(args)
